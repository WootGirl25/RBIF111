---
title: "R Notebook"
output: html_notebook
---
Download data & check normalization
```{r}
#download raw series counts - use rnaseq data
counts_data <- read.table("GSE119290_Readhead_2018_RNAseq_gene_counts.txt", header = TRUE, sep = "\t", row.names = 1)
#download phenotypic data
geo <- getGEO("GSE119290", GSEMatrix = TRUE)
pheno <- pData(geo[[1]])
save(pheno, file = "GSE119290_pheno.Rda")
load("GSE119290_pheno.Rda")
boxplot(counts_data)
boxplot(counts_data, ylim=c(0,4000)) #var vastly different
```



#Question 1

#Question 2
```{r}

```



#Question 3
```{r}
#### HC for top 100, 1000, and all genes ####
#make list of gene sets so can loop and do all at once
gene_sets <- list(
  top100 = counts_top100,
  top1000 = counts_top1000,
  all = counts_data
)

clust_results <- list() #for clustering results

oldpar <- par(mfrow = c(1, 3)) 
for (set in names(gene_sets)) {
  matrix <- gene_sets[[set]]
  d <- dist(t(matrix)) #dist calculates distances b/w rows, for patiens must transpose
  hc <- hclust(d, method = "complete")
  clust_results[[set]] <- hc
  plot(hc, main = paste("Dendrogram:", set), xlab = "", sub = "", cex = 0.7)
}
par(oldpar)
```
Discuss:\

```{r}
##CHOICES: ward.D2 + Euclidean, average(UPGMA) + Euclidean, Spearman + Complete linkage
oldpar <- par(mfrow = c(1, 3)) 
for (set in names(gene_sets)) {
  matrix <- gene_sets[[set]]
  clust_results[[set]] <- list()
  
  #distance= Eucilidan for complete, ward.D2 and average
  d.euc <- dist(t(matrix))
  
  #linkage=complete
  # clust.ec <- hclust(d.euc, method = "complete")
  # clust_results[[set]][["complete"]] <- clust.ec
  # plot(clust.ec, main = paste(set, "Euclidean + complete"), xlab = "", sub = "", cex = 0.7)
  
  #linkage= ward.D2 
  clust.wardd2 <- hclust(d.euc, method = "ward.D2")
  clust_results[[set]][["ward.D2"]] <- clust.wardd2
  plot(clust.wardd2, main = paste(set, "Euclidean + ward.D2"), xlab = "", sub = "", cex = 0.7)
  
  #linkage= average 
  clust.avg <- hclust(d.euc, method = "average")
  clust_results[[set]][["average"]] <- clust.avg
  plot(clust.avg, main = paste(set, "Euclidean + average"), xlab = "", sub = "", cex = 0.7)
  
  #distance= Spearman + linkage= complete 
  d.spear <- as.dist(1 - cor(matrix, method = "spearman"))
  clust.spear <- hclust(d.spear, method = "complete")
  clust_results[[set]][["spearman"]] <- clust.spear
  plot(clust.spear, main = paste(set, "Spearman + complete"), xlab = "", sub = "", cex = 0.7)
}
par(oldpar)

```
Discuss:\ NOT YET WRITTEN


#Question 4
```{r}
#order genes by variance
ordered_counts <- counts_data[order(gene_vars, decreasing = TRUE),]

#find exponential slices, 256^2 is larger than number of genes, will have to cut short
slice_sizes <- c(4)
while (tail(slice_sizes,1) < nrow(ordered_counts)){
  nextsize <- tail(slice_sizes,1)^2 #square the last size in the vector
  slice_sizes <- c(slice_sizes, nextsize) #add to vector
}
#make length of last slice == nrow, it will make it the index of last row - then can select into groups
slice_sizes[length(slice_sizes)] <- nrow(ordered_counts); slice_sizes #check
#create slices (use lapply since slices are in a vector)
data_slices <- lapply(slice_sizes, 
                      function(size){
                        ordered_counts[1:size,]
                      })

#perform clustering, save dendograms and histogram heights so know where to cut
dendograms <- list()
hist_heights <- list()

for (i in 1:length(data_slices)){
  slice <- data_slices[[i]]
  clust <- hclust(dist(t(slice)), method = "ward.D2")
  dendrograms[[i]] <- clust
  hist_heights[[i]] <- hist(clust$height, breaks = 50, main= paste("Hist of merge heights- slice", i), xlab= "height")
}
```
```{r}
#order genes by variance
ordered_counts <- counts_data[order(gene_vars, decreasing = TRUE),]

#find exponential slices, 256^2 is larger than number of genes, will have to cut short
slice_sizes <- c(4)
while (tail(slice_sizes,1) < nrow(ordered_counts)){
  nextsize <- tail(slice_sizes,1)^2 #square the last size in the vector
  slice_sizes <- c(slice_sizes, nextsize) #add to vector
}
#make length of last slice == nrow, it will make it the index of last row - then can select into groups
slice_sizes[length(slice_sizes)] <- nrow(ordered_counts); slice_sizes #check
#create slices (use lapply since slices are in a vector)
data_slices <- lapply(slice_sizes, function(size){ordered_counts[1:size,]})

# 4a. Perform clustering and plot histograms (do NOT cut yet)
dendrograms <- lapply(data_slices, function(slice) {
  hcwd2 <- hclust(dist(t(slice)), method = "ward.D2")
  hist(hcwd2$height, breaks = 50, main = paste("Hist of merge heights -", nrow(slice), "genes"), xlab = "height")
  return(hcwd2)
})

#looks like they all drop off ~400,000 - try this as cut height
cut_height <- 400000
cluster_list <- lapply(dendrograms, function(hcwd2) {
  cutree(hcwd2, h = cut_height)
})

# 5. Combine cluster lists into a matrix (samples x slices)
sample_names <- colnames(counts_data)
cluster_matrix <- sapply(cluster_list, function(clusters) clusters[sample_names]) #reorder each vector in cluster_lists to match order of sample_names

# For each sample, count how many times it is assigned to its most common cluster
leaf_stability <- apply(cluster_matrix, 1, function(x) {
  max(table(x))
})

# Print the stability count for each sample -leaf stability gives the most time that sample was in the same cluster across all 4 slices. if =4, means in the same cluster each time
print(leaf_stability)
```

```{r}
# 1. For each sample, find its most common cluster assignment across all slices
most_common_cluster <- apply(cluster_matrix, 1, function(x) {
  as.integer(names(which.max(table(x))))
})

# 2. For each slice, count how many samples match their most common assignment
slice_stability <- apply(cluster_matrix, 2, function(col) {
  sum(col == most_common_cluster)
})

# 3. Find the slice with the greatest number of stable leaves
best_slice_index <- which.max(slice_stability)
best_slice_size <- slice_sizes[best_slice_index]

# print how many samples matched in each slice
cat("Matches in each slice are", slice_stability)
cat("\nMost stable dendrogram is for", best_slice_size, "genes (slice", best_slice_index, ")\n")
print("Dendrogram for most stable slice:")
#return dendrogram for splice 1
```

The "tree with the greatest number of leaves that are similar to the rest of the trees" is the dendrogram (slice) where the most samples are clustered in agreement with their most common cluster assignment across all slices.
This tree is considered the most stable or representative of the overall clustering structure.