---
title: Week 2 Homework
author: "Author: Laura Wooten"
date: "Last update: `r format(Sys.time(), '%d %B, %Y')`" 
output: html_notebook
---

> For this homework assignment, you will need to download a data set from the UCI machine learning repository. Separate the data set you downloaded into two groups by the outcome variable that is being studied. For most of the data sets in the UCR machine learning repository, most of the time, this will be categorical variable in the “last column” in the data set. If more than one outcome was studied, use the one with the greatest number of records. Then do the following:

UCI machine learning repo site was down - using Maternal Health Risk Data Set that you sent me via email.
Steps:
1. read in csv file  
2. preview data, how many levels/outcomes for variable being explored?   
3. Create 2 groups: low-risk and high risk 
```{r}
MatRisk <- read.csv("Maternal Health Risk Data Set.csv")
#preivew
MatRisk[1:5,]
class(MatRisk)
unlist(lapply(MatRisk[,1:7],class))
#Change $RiskLevel from chr to factor so can assess levels
MatRisk$RiskLevel <- as.factor(MatRisk$RiskLevel)
class(MatRisk$RiskLevel)
#check levels of  
risk.levels <- levels(MatRisk$RiskLevel); risk.levels
```
```{r eval=FALSE, include=FALSE}
#which level has greatest # records? - dont need anymore
max.obs <- 0
most.frequent <- NULL

for (i in risk.levels) {
  Nobs <- sum(MatRisk$RiskLevel == i)  # Count the # of observations for each level
  if (Nobs > max.obs) {
    max.obs <- Nobs
    most.frequent <- i  # Store the level with the greatest frequency
  }
}
print(paste('Level with greatest number of records:', most.frequent))
```

```{r}
#Separate into two groups
lowrisk <- MatRisk[MatRisk$RiskLevel == 'low risk',]; #select all columns for rows whose risklevel is low
highrisk <- MatRisk[MatRisk$RiskLevel == 'high risk',]; #select all other rows
rm(list=setdiff(ls(), c("lowrisk", "highrisk")))
```


> 1. 20 points Perform normality tests for each data feature. At a minimum, these normality tests should include a Shapiro-Wilks normality test along with a qq-plot. Describe the results of these tests.

```{r eval=FALSE, include=FALSE}
for (feature.name in names(lowrisk)[1:6]){ #column 7 is non numerical - leave out
  feature.vec <- lowrisk[[feature.name]] #column as a vector
  test <- shapiro.test(feature.vec)
  if(test$p.value < 0.05){
    distribution <- "Not normally distributed"
  }else{
    distribution <- "Normally distributed"
  }
  print(paste(feature.name, ":", distribution))
  
  #plot qq
  qqnorm(feature.vec, main= paste('QQ-Plot of', feature.name))
  qqline(feature.vec, col= "blue")
  
  #histogram
  hist(feature.vec, main = paste('Histogram of', feature.name))
}
# shapiro.test(df$column)
# 
# # create qq plot of 1st column in df
# qqnorm(df[,1], main= "QQ plot of column")
# qqline(df[,1], col= "red")

```
I was confused as to whether or not to implement this using the entire data set or the partitioned data set, so I did both just to see the differences. 
```{r}
#using entire dataset
# First loop: Print only textual results
for (feature.name in names(MatRisk)[1:6]){
  feature.vec <- MatRisk[[feature.name]]
  test <- shapiro.test(feature.vec)
  
  if(test$p.value < 0.05){
    distribution <- "Not normally distributed"
  }else{
    distribution <- "Normally distributed"
  }
  
  print(paste(feature.name, ":", distribution))
}

# Second loop: Generate plots

for (feature.name in names(MatRisk)[1:6]){
  feature.vec <- MatRisk[[feature.name]]
  
  par(mfrow = c(1, 2)) #plot side by side
  # QQ-plot
  qqnorm(feature.vec, main = paste("QQ-Plot of", feature.name))
  qqline(feature.vec, col = "blue")
  
  # Histogram
  hist(feature.vec, main = paste("Histogram of", feature.name), xlab= "Recorded Value", col="lightblue", border= "white")
  
  
  
}
```


```{r}
# First loop: Print only textual results
for (feature.name in names(lowrisk)[1:6]){
  feature.vec <- lowrisk[[feature.name]]
  test <- shapiro.test(feature.vec)
  
  if(test$p.value < 0.05){
    distribution <- "Not normally distributed"
  }else{
    distribution <- "Normally distributed"
  }
  
  print(paste(feature.name, ":", distribution))
}

# Second loop: Generate plots

for (feature.name in names(lowrisk)[1:6]){
  feature.vec <- lowrisk[[feature.name]]
  
  par(mfrow = c(1, 2)) #plot side by side
  # QQ-plot
  qqnorm(feature.vec, main = paste("QQ-Plot of", feature.name))
  qqline(feature.vec, col = "blue")
  
  # Histogram
  hist(feature.vec, main = paste("Histogram of", feature.name), xlab= "Recorded Value", col="lightblue", border= "white")
  
  
  
}



```
**Discuss results**
The Shapiro tests for each column indicate that this data is not normalized, meaning there is more than just chance that the values are different between the outcome variables. When looking at the QQ-plots they don't follow the theoretical line that indicates a normal distribution, and histograms also don't appear to be in a bell shaped curve. The only plots that look like they could be close to a normal distribution is data for HeartRate, but the Shapiro tests still come back as p < 0.05, so we can assume that even though this one is close, to treat it as a non normalized data. 

---
> 2. 20 points Create a box plot with each column of the data set on the x-axis, the value of the columns on the y-axis, and colored by the outcome that is being studied.

```{r}
#I think?
#boxplot(highrisk$Age~highrisk$RiskLevel, ylab = "value name") Uses same df. my results have been separated into to data frames


par(mfrow = c(2, 3)) # Arrange plots in a 2x3 grid

boxplot(highrisk$Age, lowrisk$Age, names = c("High Risk", "Low Risk"), main = "Age by RiskLevel", col = c("red", "blue"))
boxplot(highrisk$BS, lowrisk$BS, names = c("High Risk", "Low Risk"), main = "BS by RiskLevel", col = c("red", "blue"))
boxplot(highrisk$BodyTemp, lowrisk$BodyTemp, names = c("High Risk", "Low Risk"), main = "BodyTemp by RiskLevel", col = c("red", "blue"))

boxplot(highrisk$HeartRate, lowrisk$HeartRate, names = c("High Risk", "Low Risk"), main = "HeartRate by RiskLevel", col = c("red", "blue"))
boxplot(highrisk$SystolicBP, lowrisk$SystolicBP, names = c("High Risk", "Low Risk"), main = "Systolic BP by RiskLevel", col = c("red", "blue"))
boxplot(highrisk$DiastolicBP, lowrisk$DiastolicBP, names = c("High Risk", "Low Risk"), main = "DistolicBP by RiskLevel", col = c("red", "blue"))

```
Would have used the "~" sign to plot each column of data against RiskLevel like in the lecture notes (eg `boxplot(MatRisk$Age ~ MatRisk$RiskLevel, col=c(red, blue))`), but instructions said to separate the data into two distinct groups before continuing. The box plots reveal clear differences between the low-risk and high-risk maternal groups. The average values for age, blood sugar (BS), systolic blood pressure, and diastolic blood pressure are all higher for the high-risk group compared to the low-risk group. Moreover, the range of values is wider in the high-risk category, indicating more variability in these health measures. In contrast, mothers in the low-risk group consistently stay within healthy norms. This suggests that high-risk outcomes are influenced by a broader spectrum of factors. 

> 3. 20 points Perform hypothesis tests comparing paired columns of the partitioned data set. You will need to determine which hypothesis test to perform based on your normality test results.

The normality tests results indicate that data for each column is not parametrically distributed, therefore I have used a Mann-Whitney U Test to perform hypothesis testing for each column. My understanding of this question is that I need to compare each feature between outcome, for example does the Age of patients with high risk statistically differ to the distribution of ages of patients with low risk. To do this I have marked paired = False as an argument in the wilcox.test() function because the paired argument here is referring to measurements taken for that sample (ie that patient) which would be analyzing results from within the same row of a dataframe.

```{r}
for (feature.name in names(lowrisk)[1:6]){
  hr.feature <- highrisk[[feature.name]]
  lr.feature <- lowrisk[[feature.name]]
  test.result <- wilcox.test(hr.feature, lr.feature, conf.int =T, paired = F, formula="lhs" )
  
  print(paste("Mann-Whitney U Test for:", feature.name))
  print(test.result)
  
        
}
```
The p-values for each feature are less than 0.05, meaning that we reject the null hypothesis and accept the alternate hypothesis that states that the differences in each each feature by outcome do not come from the same distribution, and therefore are not occurring by chance. This indicates that there is legitimate reasoning behind the differences seen for each feature and they are somehow connected/specific to the outcome being studied, in this case maternal risk. 


> 4. 40 points Select a column of the data set with the greatest variance and overlap between outcome groups. Take a random sampling of the data with different sample sizes (say, 10, 15, 20 samples) from both groups. Then perform a hypothesis test between both groups and retain the p-value. Repeat this process 1000 times. For each iteration, save the p-values in a vector called Pvals. Then plot the distribution of significance tests for each re-sampling. Repeat this process with the column with the least variance and overlap between outcome groups. Explain the results and the differences between both simulations.


From the box plots, it appears that the column with the greatest variance and overlap is DiastolicBP. This is visually apparent looking at the overlap between the IQR and outliers, as well as the stretch of each in either direction to view the variance. However if we wanted to quantify the difference to know for sure we could use the following:

Take a random sampling:
```{r}
set.seed(12)
#create vectors
h.diastolic <- highrisk$DiastolicBP
l.diastolic <- lowrisk$DiastolicBP

#select random samples
h.10 <- sample(h.diastolic[!is.na(h.diastolic)], 10) #random sample of 10
l.10 <- sample(l.diastolic[!is.na(l.diastolic)], 10) #random sample of 10
h.15 <- sample(h.diastolic[!is.na(h.diastolic)], 15) #random sample of 15
l.15 <- sample(l.diastolic[!is.na(l.diastolic)], 15) #random sample of 15
h.20 <- sample(h.diastolic[!is.na(h.diastolic)], 20) #random sample of 20
l.20 <- sample(l.diastolic[!is.na(l.diastolic)], 20) #random sample of 20

#combine samples,
```


perform hypothesis test between groups:

rpt 1000 times, save p-values

Plot the distribution of p-values

Repeat this with least variance and overlap column: 

